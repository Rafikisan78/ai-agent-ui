<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tests Workflow N8N</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      background: white;
      border-radius: 10px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #666;
      font-size: 14px;
    }

    .meta-line {
      color: #999;
      font-size: 13px;
      margin-top: 5px;
    }

    .workflow-selector {
      border: 2px dashed #cbd5e0;
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 16px;
      background: #f7fafc;
    }

    .workflow-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .pill-active {
      background: #c6f6d5;
      color: #22543d;
      border: 1px solid #48bb78;
    }

    .pill-inactive {
      background: #fed7d7;
      color: #742a2a;
      border: 1px solid #f56565;
    }

    .small-note {
      color: #718096;
      font-size: 12px;
    }

    .controls {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-success {
      background: #48bb78;
      color: white;
    }

    .btn-info {
      background: #4299e1;
      color: white;
    }

    .btn-warning {
      background: #ed8936;
      color: white;
    }

    .btn-danger {
      background: #f56565;
      color: white;
    }

    .results {
      background: white;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .test-result {
      margin-bottom: 30px;
      padding: 20px;
      border-radius: 8px;
      border-left: 4px solid #ccc;
    }

    .test-result.running {
      border-left-color: #4299e1;
      background: #ebf8ff;
    }

    .test-result.pass {
      border-left-color: #48bb78;
      background: #f0fff4;
    }

    .test-result.fail {
      border-left-color: #f56565;
      background: #fff5f5;
    }

    .test-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .test-status {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }

    .status-running {
      background: #4299e1;
      color: white;
    }

    .status-pass {
      background: #48bb78;
      color: white;
    }

    .status-fail {
      background: #f56565;
      color: white;
    }

    .assertion {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 4px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .assertion.pass {
      background: #c6f6d5;
      color: #22543d;
    }

    .assertion.fail {
      background: #fed7d7;
      color: #742a2a;
    }

    .assertion-details {
      font-size: 12px;
      color: #666;
      margin-left: 24px;
    }

    .summary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 10px;
      margin-top: 20px;
      text-align: center;
    }

    .summary-stats {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 48px;
      font-weight: 700;
    }

    .stat-label {
      font-size: 14px;
      opacity: 0.9;
      margin-top: 5px;
    }

    .json-output {
      background: #2d3748;
      color: #68d391;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-x: auto;
      margin-top: 10px;
    }

    .expected-response {
      background: #f7fafc;
      border: 2px dashed #cbd5e0;
      border-radius: 6px;
      padding: 15px;
      margin-top: 10px;
      font-size: 13px;
    }

    .expected-response h4 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .expected-response pre {
      background: #2d3748;
      color: #68d391;
      padding: 10px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      overflow-x: auto;
      margin: 5px 0;
    }

    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading {
      opacity: 0.6;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üß™ Tests Workflow N8N</h1>
      <p class="subtitle" id="workflowName">AI Agent Multimodal - DALL-E + Replicate Video</p>
      <p class="meta-line" id="workflowId">Workflow ID: SYKtWT1uWl7GlsKq</p>
      <p class="meta-line">Webhook: <span id="workflowWebhook">https://n8n.srv766650.hstgr.cloud/webhook/ai-agent-fiable</span></p>
    </div>

    <div class="controls">
      <div class="workflow-selector">
        <div class="workflow-row" style="justify-content: space-between;">
          <div>
            <div style="color: #667eea; font-weight: 700; margin-bottom: 4px;">S√á¬∏lection du workflow N8N</div>
            <div class="small-note">Choisissez un workflow, l'URL du webhook et l'affichage s'adapteront automatiquement.</div>
          </div>
          <span class="pill pill-active" id="workflowStatus">Actif</span>
        </div>
        <div class="workflow-row" style="margin-top: 12px;">
          <select
            id="workflowSelect"
            style="flex: 1; min-width: 240px; padding: 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; background: white;"
          >
            <option value="SYKtWT1uWl7GlsKq">AI Agent Multimodal - DALL-E + Replicate Video</option>
          </select>
          <button class="btn-info" id="refreshWorkflowsBtn" onclick="loadWorkflows()">Rafraichir</button>
        </div>
        <div class="small-note" id="workflowWebhookLabel" style="margin-top: 8px;">Webhook actif: https://n8n.srv766650.hstgr.cloud/webhook/ai-agent-fiable</div>
        <div class="small-note" id="workflowLoading" style="margin-top: 6px; display: none;">Chargement des workflows...</div>
      </div>
      <div class="button-group">
        <button class="btn-primary" onclick="runAllTests()">‚ñ∂Ô∏è Lancer Tous les Tests</button>
        <button class="btn-info" onclick="clearResults()">üóëÔ∏è Effacer</button>
      </div>

      <div style="margin-top: 20px;">
        <h3 style="margin-bottom: 15px; color: #667eea;">üìù Test Texte</h3>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
          <input
            type="text"
            id="textMessage"
            placeholder="Entrez votre message texte..."
            value=""
            style="flex: 1; padding: 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;"
          />
          <button id="textTestButton" class="btn-success" onclick="runTest('text')">‚ñ∂Ô∏è Tester</button>
        </div>

        <!-- Zone de r√©ponse directe -->
        <div id="textResponseBox" style="display: none; margin: 15px 0; padding: 15px; background: #f0fff4; border-left: 4px solid #48bb78; border-radius: 8px;">
          <h4 style="color: #48bb78; margin-bottom: 10px;">üí¨ R√©ponse</h4>
          <div id="textResponseContent" style="color: #2d3748; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"></div>
        </div>
      </div>

      <div style="margin-top: 20px;">
        <h3 style="margin-bottom: 15px; color: #667eea;">üñºÔ∏è Test Image</h3>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
          <input
            type="text"
            id="imagePrompt"
            placeholder="Description de l'image (sans /image)..."
            value=""
            style="flex: 1; padding: 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;"
          />
          <button class="btn-info" id="imageTestButton" onclick="runTest('image')">‚ñ∂Ô∏è Tester</button>
        </div>

        <!-- Zone de r√©ponse directe pour image -->
        <div id="imageResponseBox" style="display: none; margin: 15px 0; padding: 15px; background: #ebf8ff; border-left: 4px solid #4299e1; border-radius: 8px;">
          <h4 style="color: #4299e1; margin-bottom: 10px;">üñºÔ∏è Image G√©n√©r√©e</h4>
          <img id="imageResponseContent" src="" alt="Image g√©n√©r√©e" style="max-width: 100%; border-radius: 6px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: none;" />
          <div id="imageResponseText" style="color: #2d3748; margin-top: 10px; font-size: 14px;"></div>
        </div>
      </div>

      <div style="margin-top: 20px;">
        <h3 style="margin-bottom: 15px; color: #667eea;">üé¨ Test Video</h3>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
          <input
            type="text"
            id="videoPrompt"
            placeholder="Description de la vid√©o (sans /video)..."
            value=""
            style="flex: 1; padding: 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;"
          />
          <button id="videoTestButton" class="btn-warning" onclick="runTest('video')">‚ñ∂Ô∏è Tester</button>
        </div>

        <!-- Param√®tres vid√©o -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; padding: 15px; background: #f7fafc; border-radius: 6px;">
          <div>
            <label style="display: block; font-size: 12px; color: #4a5568; margin-bottom: 5px;">‚è±Ô∏è Dur√©e (secondes)</label>
            <select id="videoDuration" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
              <option value="3">3 secondes</option>
              <option value="5" selected>5 secondes</option>
              <option value="10">10 secondes</option>
            </select>
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #4a5568; margin-bottom: 5px;">üìê Format</label>
            <select id="videoAspectRatio" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
              <option value="16:9" selected>16:9 (Paysage)</option>
              <option value="9:16">9:16 (Portrait)</option>
              <option value="1:1">1:1 (Carr√©)</option>
            </select>
          </div>
          <div>
            <label style="display: block; font-size: 12px; color: #4a5568; margin-bottom: 5px;">üé® FPS</label>
            <select id="videoFps" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
              <option value="6">6 FPS</option>
              <option value="12">12 FPS</option>
              <option value="24" selected>24 FPS</option>
            </select>
          </div>
        </div>

        <!-- Zone de r√©ponse directe pour vid√©o -->
        <div id="videoResponseBox" style="display: none; margin: 15px 0; padding: 15px; background: #fff5f5; border-left: 4px solid #ed8936; border-radius: 8px;">
          <h4 style="color: #ed8936; margin-bottom: 10px;">üé¨ Vid√©o</h4>
          <video id="videoResponseContent" controls style="max-width: 100%; border-radius: 6px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: none;">
            <source src="" type="video/mp4">
            Votre navigateur ne supporte pas la lecture vid√©o.
          </video>
          <div id="videoResponseText" style="color: #2d3748; margin-top: 10px; font-size: 14px;"></div>

          <!-- Zone pour coller manuellement l'URL de la vid√©o -->
          <div id="manualVideoUrlBox" style="margin-top: 15px; padding-top: 15px; border-top: 2px dashed #fed7d7; display: none;">
            <label style="display: block; color: #ed8936; font-weight: 600; margin-bottom: 8px;">
              üìé Coller l'URL de la vid√©o g√©n√©r√©e (depuis Replicate):
            </label>
            <div style="display: flex; gap: 10px; align-items: center;">
              <input
                type="text"
                id="manualVideoUrl"
                placeholder="https://replicate.delivery/pbxt/... ou https://replicate.com/p/..."
                style="flex: 1; padding: 10px; border: 2px solid #fed7d7; border-radius: 6px; font-size: 14px;"
              />
              <button class="btn-warning" onclick="loadManualVideoUrl()" style="white-space: nowrap;">
                ‚ñ∂Ô∏è Charger la vid√©o
              </button>
            </div>
            <p style="color: #718096; font-size: 12px; margin-top: 8px;">
              üí° Collez l'URL de la vid√©o depuis Replicate (format .mp4) et cliquez sur "Charger la vid√©o"
            </p>
          </div>
        </div>
      </div>

      <div style="margin-top: 20px;">
        <h3 style="margin-bottom: 15px; color: #667eea;">üé§ Test Voix</h3>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
          <button id="recordButton" class="btn-danger" onclick="toggleRecording()" style="min-width: 150px;">
            üé§ Commencer l'enregistrement
          </button>
          <span id="recordingStatus" style="color: #999; font-size: 13px;"></span>
          <span id="recordingTimer" style="color: #667eea; font-weight: bold; font-size: 14px;"></span>
        </div>

        <!-- Zone de visualisation audio -->
        <div id="audioPreview" style="display: none; margin: 15px 0; padding: 15px; background: #f7fafc; border-radius: 8px; border: 2px solid #667eea;">
          <h4 style="color: #667eea; margin-bottom: 10px;">üîä Aper√ßu de l'enregistrement</h4>
          <audio id="audioPlayback" controls style="width: 100%; margin-bottom: 10px;"></audio>
          <div style="display: flex; gap: 10px;">
            <button id="voiceTestButton" class="btn-success" onclick="runTest('voice')">‚ñ∂Ô∏è Envoyer au Webhook</button>
            <button class="btn-warning" onclick="resetRecording()">üîÑ R√©enregistrer</button>
          </div>
        </div>

        <!-- Zone de transcription -->
        <div id="voiceResponseBox" style="display: none; margin: 15px 0; padding: 15px; background: #f0fff4; border-left: 4px solid #48bb78; border-radius: 8px;">
          <h4 style="color: #48bb78; margin-bottom: 10px;">üìù Transcription</h4>
          <div id="voiceResponseText" style="color: #2d3748; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"></div>
        </div>
        <div class="expected-response">
          <h4>üìã R√©ponse Attendue (Format Voix ‚Üí Texte)</h4>
          <pre id="voiceExpected">{
  "type": "text",
  "prompt": "transcription audio",
  "response": "Voici la r√©ponse √† votre question...",
  "source": "voice",
  "originalMessage": "transcription audio",
  "transcription": "transcription audio"
}</pre>
          <p style="color: #718096; margin-top: 10px; font-size: 12px;">
            ‚ö†Ô∏è N√©cessite OpenAI Whisper configur√© dans N8N<br>
            ‚ÑπÔ∏è L'audio est transcrit puis trait√© comme du texte
          </p>
        </div>
      </div>
    </div>

    <div class="results" id="results">
      <p style="text-align: center; color: #999;">Cliquez sur un bouton pour lancer les tests</p>
    </div>
  </div>

  <script>
    const N8N_BASE_URL = 'https://n8n.srv766650.hstgr.cloud';
    const N8N_API_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYmFlYjc5NS00Nzc2LTQzOTctOWY5Yi0xNjExZDliZWY2ZmUiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzY2NjAxMjMxLCJleHAiOjE3NjkxMjI4MDB9.VhubODyH6ZKscdzr4RmRUZh4NIaWG6HxGhmnJ7V7UKs';
    const DEFAULT_WORKFLOW_ID = 'SYKtWT1uWl7GlsKq';
    const DEFAULT_WEBHOOK_URL = 'https://n8n.srv766650.hstgr.cloud/webhook/ai-agent-fiable';
    const DEFAULT_WORKFLOW_NAME = (document.getElementById('workflowName')?.textContent || 'Workflow N8N').trim();

    let WEBHOOK_URL = DEFAULT_WEBHOOK_URL;
    let totalTests = 0;
    let passedTests = 0;
    let failedTests = 0;
    let workflowsCache = [];
    let currentWorkflow = {
      id: DEFAULT_WORKFLOW_ID,
      name: DEFAULT_WORKFLOW_NAME,
      webhookUrl: DEFAULT_WEBHOOK_URL,
      active: true
    };

    function normalizeBaseUrl(url) {
      return (url || '').replace(/\/+$/, '');
    }

    function buildWebhookUrl(path) {
      if (!path) return null;
      const cleanPath = String(path).replace(/^\/+/, '');
      const base = normalizeBaseUrl(N8N_BASE_URL);
      if (!base) return null;
      return cleanPath.startsWith('webhook') ? `${base}/${cleanPath}` : `${base}/webhook/${cleanPath}`;
    }

    function extractWebhookInfo(workflow) {
      const nodes = workflow?.nodes || [];
      const webhookNode = nodes.find(node => node.type === 'n8n-nodes-base.webhook');
      const path = webhookNode?.parameters?.path || workflow?.webhookId || null;
      return { path, webhookUrl: buildWebhookUrl(path) };
    }

    function updateWorkflowUI(statusMessage) {
      const nameEl = document.getElementById('workflowName');
      const idEl = document.getElementById('workflowId');
      const webhookEl = document.getElementById('workflowWebhook');
      const statusEl = document.getElementById('workflowStatus');
      const labelEl = document.getElementById('workflowWebhookLabel');
      const loadingEl = document.getElementById('workflowLoading');

      if (nameEl) nameEl.textContent = currentWorkflow.name;
      if (idEl) idEl.textContent = `Workflow ID: ${currentWorkflow.id}`;
      if (webhookEl) webhookEl.textContent = currentWorkflow.webhookUrl || 'Non d√©finie';
      if (labelEl) labelEl.textContent = `Webhook actif: ${currentWorkflow.webhookUrl || 'Non d√©finie'}`;
      if (statusEl) {
        statusEl.textContent = currentWorkflow.active ? 'Actif' : 'Inactif';
        statusEl.className = `pill ${currentWorkflow.active ? 'pill-active' : 'pill-inactive'}`;
      }
      if (loadingEl && statusMessage) {
        loadingEl.style.display = 'block';
        loadingEl.textContent = statusMessage;
      } else if (loadingEl) {
        loadingEl.style.display = 'none';
      }

      document.querySelectorAll('.workflow-name').forEach(el => {
        el.textContent = currentWorkflow.name;
      });
    }

    function setCurrentWorkflow(workflow) {
      if (!workflow) return;
      currentWorkflow = {
        id: workflow.id || DEFAULT_WORKFLOW_ID,
        name: workflow.name || DEFAULT_WORKFLOW_NAME,
        webhookUrl: workflow.webhookUrl || DEFAULT_WEBHOOK_URL,
        active: workflow.active !== undefined ? workflow.active : true
      };
      WEBHOOK_URL = currentWorkflow.webhookUrl || DEFAULT_WEBHOOK_URL;
      updateWorkflowUI();
      updateExpectedResponses();
    }

    function getActiveWebhookUrl() {
      return WEBHOOK_URL || DEFAULT_WEBHOOK_URL;
    }

    // Mettre √† jour les exemples de r√©ponses attendues dynamiquement
    function updateExpectedResponses() {
      const textMessage = document.getElementById('textMessage').value;
      const imagePrompt = document.getElementById('imagePrompt').value;
      const videoPrompt = document.getElementById('videoPrompt').value;

      // Texte
      document.getElementById('textExpected').textContent = `{
  "type": "text",
  "prompt": "${textMessage}",
  "response": "R√©ponse g√©n√©r√©e par l'IA...",
  "source": "text",
  "originalMessage": "\\\\text ${textMessage}"
}`;

      // Image
      document.getElementById('imageExpected').textContent = `{
  "type": "image",
  "prompt": "${imagePrompt}",
  "image_url": "https://oaidalleapiprodscus.blob.core.windows.net/...",
  "response": "Image g√©n√©r√©e avec succ√®s",
  "source": "text",
  "originalMessage": "\\\\image ${imagePrompt}"
}`;

      // Video - Processing
      document.getElementById('videoExpectedProcessing').textContent = `{
  "type": "video",
  "prompt": "${videoPrompt}",
  "status": "processing",
  "task_id": "abc123-def456-ghi789",
  "response": "G√©n√©ration vid√©o en cours...",
  "source": "text",
  "originalMessage": "\\\\video ${videoPrompt}"
}`;

      // Video - Complete
      document.getElementById('videoExpectedComplete').textContent = `{
  "type": "video",
  "prompt": "${videoPrompt}",
  "status": "completed",
  "video_url": "https://replicate.delivery/pbxt/...",
  "response": "Vid√©o g√©n√©r√©e avec succ√®s",
  "source": "text",
  "originalMessage": "\\\\video ${videoPrompt}"
}`;
    }

    // √âcouter les changements sur les champs
    async function loadWorkflows() {
      const selectEl = document.getElementById('workflowSelect');
      const loadingEl = document.getElementById('workflowLoading');
      const refreshBtn = document.getElementById('refreshWorkflowsBtn');

      if (!selectEl) return;

      if (refreshBtn) refreshBtn.disabled = true;
      if (loadingEl) {
        loadingEl.style.display = 'block';
        loadingEl.textContent = 'Chargement des workflows...';
      }

      if (!N8N_API_KEY) {
        updateWorkflowUI('Cle API N8N manquante, utilisation du webhook par defaut.');
        if (refreshBtn) refreshBtn.disabled = false;
        return;
      }

      try {
        const response = await fetch(`${normalizeBaseUrl(N8N_BASE_URL)}/api/v1/workflows`, {
          method: 'GET',
          headers: {
            'X-N8N-API-KEY': N8N_API_KEY,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const payload = await response.json();
        const rawWorkflows = Array.isArray(payload?.data) ? payload.data : (Array.isArray(payload) ? payload : []);
        workflowsCache = rawWorkflows
          .map(wf => {
            const webhookInfo = extractWebhookInfo(wf);
            return {
              id: wf.id,
              name: wf.name || `Workflow ${wf.id}`,
              webhookUrl: webhookInfo.webhookUrl,
              active: wf.active
            };
          })
          .filter(wf => wf.webhookUrl);

        if (!workflowsCache.length) {
          throw new Error('Aucun webhook trouve dans les workflows recuperes.');
        }

        selectEl.innerHTML = '';
        workflowsCache.forEach(wf => {
          const option = document.createElement('option');
          option.value = wf.id;
          option.textContent = wf.name;
          selectEl.appendChild(option);
        });

        const selected = workflowsCache.find(w => w.id === currentWorkflow.id) || workflowsCache[0];
        selectEl.value = selected.id;
        setCurrentWorkflow(selected);
        updateWorkflowUI(`Workflows charges (${workflowsCache.length})`);
      } catch (error) {
        updateWorkflowUI(`Erreur de chargement: ${error.message}`);
      } finally {
        if (loadingEl) {
          setTimeout(() => { loadingEl.style.display = 'none'; }, 2000);
        }
        if (refreshBtn) refreshBtn.disabled = false;
      }
    }
    // Fonction pour afficher la vid√©o depuis les param√®tres URL
    function displayVideoFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const videoUrl = urlParams.get('video_url') || urlParams.get('videoUrl') || urlParams.get('url');

      if (videoUrl) {
        console.log('üé¨ Vid√©o d√©tect√©e dans l\'URL:', videoUrl);

        const videoResponseBox = document.getElementById('videoResponseBox');
        const videoResponseContent = document.getElementById('videoResponseContent');
        const videoResponseText = document.getElementById('videoResponseText');

        // D√©terminer le type de vid√©o
        let videoType = 'video/mp4';
        if (videoUrl.includes('.webm')) {
          videoType = 'video/webm';
        } else if (videoUrl.includes('.mov')) {
          videoType = 'video/quicktime';
        }

        // Configurer la vid√©o
        let sourceElement = videoResponseContent.querySelector('source');
        if (!sourceElement) {
          sourceElement = document.createElement('source');
          videoResponseContent.appendChild(sourceElement);
        }
        sourceElement.src = videoUrl;
        sourceElement.type = videoType;
        videoResponseContent.load();
        videoResponseContent.style.display = 'block';
        videoResponseBox.style.display = 'block';

        // Afficher un message
        videoResponseText.textContent = 'Vid√©o charg√©e depuis l\'URL';

        console.log('‚úÖ Vid√©o affich√©e depuis l\'URL');
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('textMessage').addEventListener('input', updateExpectedResponses);
      document.getElementById('imagePrompt').addEventListener('input', updateExpectedResponses);
      document.getElementById('videoPrompt').addEventListener('input', updateExpectedResponses);

      const workflowSelect = document.getElementById('workflowSelect');
      if (workflowSelect) {
        workflowSelect.addEventListener('change', (event) => {
          const selected = workflowsCache.find(w => w.id === event.target.value);
          if (selected) {
            setCurrentWorkflow(selected);
            clearResults();
          }
        });
      }

      // Initialiser les valeurs au chargement
      updateExpectedResponses();
      updateWorkflowUI();
      loadWorkflows();

      // Afficher la vid√©o depuis l'URL si pr√©sente
      displayVideoFromURL();
    });

    function clearResults() {
      document.getElementById('results').innerHTML = '<p style="text-align: center; color: #999;">Cliquez sur un bouton pour lancer les tests</p>';

      // Cacher les bo√Ætes de r√©ponse directe
      const textResponseBox = document.getElementById('textResponseBox');
      const imageResponseBox = document.getElementById('imageResponseBox');
      const videoResponseBox = document.getElementById('videoResponseBox');

      if (textResponseBox) textResponseBox.style.display = 'none';
      if (imageResponseBox) imageResponseBox.style.display = 'none';
      if (videoResponseBox) videoResponseBox.style.display = 'none';

      totalTests = 0;
      passedTests = 0;
      failedTests = 0;
    }

    function createTestContainer(testId, testName) {
      const container = document.createElement('div');
      container.className = 'test-result running';
      container.id = testId;
      container.innerHTML = `
        <div class="test-title">
          <span class="spinner"></span>
          ${testName}
          <span class="test-status status-running">EN COURS</span>
        </div>
        <div class="assertions"></div>
      `;
      return container;
    }

    function addAssertion(testId, passed, testName, expected, actual) {
      totalTests++;
      if (passed) passedTests++;
      else failedTests++;

      const container = document.getElementById(testId);
      if (!container) {
        console.error(`‚ùå Container non trouv√© pour testId: ${testId}`);
        return;
      }
      const assertionsDiv = container.querySelector('.assertions');
      if (!assertionsDiv) {
        console.error(`‚ùå assertionsDiv non trouv√© dans container: ${testId}`);
        return;
      }

      const assertionEl = document.createElement('div');
      assertionEl.className = `assertion ${passed ? 'pass' : 'fail'}`;
      assertionEl.innerHTML = `
        <span>${passed ? '‚úÖ' : '‚ùå'}</span>
        <span>${testName}</span>
      `;

      if (!passed) {
        const details = document.createElement('div');
        details.className = 'assertion-details';
        details.innerHTML = `Expected: ${expected}<br>Actual: ${actual}`;
        assertionEl.appendChild(details);
      }

      assertionsDiv.appendChild(assertionEl);
    }

    function finishTest(testId, success) {
      const container = document.getElementById(testId);
      if (!container) {
        console.error(`‚ùå Container non trouv√© pour finishTest: ${testId}`);
        return;
      }
      container.className = `test-result ${success ? 'pass' : 'fail'}`;
      const spinner = container.querySelector('.spinner');
      if (spinner) spinner.remove();
      const status = container.querySelector('.test-status');
      if (status) {
        status.className = `test-status ${success ? 'status-pass' : 'status-fail'}`;
        status.textContent = success ? 'PASS ‚úÖ' : 'FAIL ‚ùå';
      }
    }

    function addJsonOutput(testId, data) {
      const container = document.getElementById(testId);

      console.log('üé® addJsonOutput appel√©e avec:', data);
      console.log('üé® Container trouv√©:', !!container);

      // Afficher la r√©ponse texte si pr√©sente (content ou response)
      const textResponse = data.response || data.content;
      console.log('üé® textResponse:', textResponse);
      console.log('üé® data.type:', data.type);
      console.log('üé® Condition affichage texte:', textResponse && data.type === 'text');

      if (textResponse && data.type === 'text') {
        console.log('‚úÖ Cr√©ation du bloc texte...');
        const textContainer = document.createElement('div');
        textContainer.style.cssText = 'margin: 15px 0; padding: 15px; background: #f0fff4; border-left: 4px solid #48bb78; border-radius: 8px;';

        const header = document.createElement('h4');
        header.style.cssText = 'color: #48bb78; margin-bottom: 10px;';
        header.textContent = 'üí¨ R√©ponse Texte';

        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = 'color: #2d3748; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;';
        contentDiv.textContent = textResponse;

        textContainer.appendChild(header);
        textContainer.appendChild(contentDiv);
        container.appendChild(textContainer);
        console.log('‚úÖ Bloc texte ajout√© au DOM');
      } else {
        console.log('‚ùå Bloc texte NON cr√©√© - condition non remplie');
      }

      // Afficher l'image si pr√©sente
      if (data.image_url) {
        const imageContainer = document.createElement('div');
        imageContainer.style.cssText = 'margin: 15px 0; padding: 15px; background: #ebf8ff; border-left: 4px solid #4299e1; border-radius: 8px;';
        const safeResponse = typeof data.response === 'string' ? data.response : (typeof data.response === 'object' ? JSON.stringify(data.response) : '');
        imageContainer.innerHTML = `
          <h4 style="color: #4299e1; margin-bottom: 10px;">üñºÔ∏è Image G√©n√©r√©e</h4>
          <img src="${data.image_url}" alt="Image g√©n√©r√©e" style="max-width: 100%; border-radius: 6px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);" onload="this.style.opacity=1" onerror="this.style.border='2px solid #f56565'; this.alt='Erreur de chargement'" style="opacity:0; transition: opacity 0.3s;" />
          ${safeResponse ? `<p style="color: #2d3748; margin-top: 10px; font-size: 14px;">${safeResponse}</p>` : ''}
        `;
        container.appendChild(imageContainer);
      }

      // Afficher la vid√©o si pr√©sente
      if (data.video_url) {
        const videoContainer = document.createElement('div');
        videoContainer.style.cssText = 'margin: 15px 0; padding: 15px; background: #fff5f5; border-left: 4px solid #ed8936; border-radius: 8px;';
        const safeResponse = typeof data.response === 'string' ? data.response : (typeof data.response === 'object' ? JSON.stringify(data.response) : '');
        const safeStatus = typeof data.status === 'string' ? data.status : String(data.status || '');
        videoContainer.innerHTML = `
          <h4 style="color: #ed8936; margin-bottom: 10px;">üé¨ Vid√©o G√©n√©r√©e</h4>
          <video controls style="max-width: 100%; border-radius: 6px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <source src="${data.video_url}" type="video/mp4">
            Votre navigateur ne supporte pas la lecture vid√©o.
          </video>
          ${safeResponse ? `<p style="color: #2d3748; margin-top: 10px; font-size: 14px;">${safeResponse}</p>` : ''}
          ${safeStatus ? `<p style="color: #718096; margin-top: 5px; font-size: 12px;">Statut: <strong>${safeStatus}</strong></p>` : ''}
        `;
        container.appendChild(videoContainer);
      }

      // Afficher le statut processing pour vid√©o en cours
      if (data.type === 'video' && data.status === 'processing' && data.task_id) {
        const processingContainer = document.createElement('div');
        processingContainer.style.cssText = 'margin: 15px 0; padding: 15px; background: #fffaf0; border-left: 4px solid #ed8936; border-radius: 8px;';
        const safeResponse = typeof data.response === 'string' ? data.response : (typeof data.response === 'object' ? JSON.stringify(data.response) : 'G√©n√©ration en cours...');
        processingContainer.innerHTML = `
          <h4 style="color: #ed8936; margin-bottom: 10px;">‚è≥ Vid√©o en Cours de G√©n√©ration</h4>
          <p style="color: #2d3748; margin-bottom: 8px;">${safeResponse}</p>
          <p style="color: #718096; font-size: 12px;">Task ID: <code style="background: #2d3748; color: #68d391; padding: 2px 6px; border-radius: 3px;">${data.task_id}</code></p>
          <p style="color: #718096; font-size: 12px; margin-top: 5px;">üí° La vid√©o sera disponible dans quelques instants. Utilisez le polling pour r√©cup√©rer le r√©sultat final.</p>
        `;
        container.appendChild(processingContainer);
      }

      // Afficher l'audio si pr√©sent
      if (data.audio_url) {
        const audioContainer = document.createElement('div');
        audioContainer.style.cssText = 'margin: 15px 0; padding: 15px; background: #f7fafc; border-left: 4px solid #667eea; border-radius: 8px;';
        audioContainer.innerHTML = `
          <h4 style="color: #667eea; margin-bottom: 10px;">üé§ Audio</h4>
          <audio controls autoplay style="width: 100%;">
            <source src="${data.audio_url}" type="audio/mpeg">
            Votre navigateur ne supporte pas la lecture audio.
          </audio>
        `;
        container.appendChild(audioContainer);
      }

      // Afficher le JSON complet
      const jsonEl = document.createElement('div');
      jsonEl.className = 'json-output';
      jsonEl.innerHTML = `<strong style="color: #68d391;">üìÑ R√©ponse JSON Compl√®te:</strong><br>${JSON.stringify(data, null, 2)}`;
      container.appendChild(jsonEl);
    }

    function showSummary() {
      const summaryEl = document.createElement('div');
      summaryEl.className = 'summary';
      const percentage = totalTests === 0 ? 0 : Math.round((passedTests / totalTests) * 100);
      summaryEl.innerHTML = `
        <h2>üìä R√©sum√© des Tests</h2>
        <div class="summary-stats">
          <div class="stat">
            <div class="stat-value">${totalTests}</div>
            <div class="stat-label">Total</div>
          </div>
          <div class="stat">
            <div class="stat-value">${passedTests}</div>
            <div class="stat-label">Passed ‚úÖ</div>
          </div>
          <div class="stat">
            <div class="stat-value">${failedTests}</div>
            <div class="stat-label">Failed ‚ùå</div>
          </div>
          <div class="stat">
            <div class="stat-value">${percentage}%</div>
            <div class="stat-label">Success Rate</div>
          </div>
        </div>
      `;
      document.getElementById('results').appendChild(summaryEl);
    }

    // Variables globales pour l'enregistrement audio
    let mediaRecorder = null;
    let audioChunks = [];
    let recordedAudioBlob = null;
    let recordingStartTime = null;
    let recordingTimer = null;

    async function toggleRecording() {
      const recordButton = document.getElementById('recordButton');
      const recordingStatus = document.getElementById('recordingStatus');
      const recordingTimerEl = document.getElementById('recordingTimer');

      if (mediaRecorder && mediaRecorder.state === 'recording') {
        // Arr√™ter l'enregistrement
        mediaRecorder.stop();
        recordButton.textContent = 'üé§ Commencer l\'enregistrement';
        recordButton.className = 'btn-danger';
        recordingStatus.textContent = 'Traitement...';
        clearInterval(recordingTimer);
      } else {
        // D√©marrer l'enregistrement
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];
          recordingStartTime = Date.now();

          // D√©marrer le timer
          recordingTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimerEl.textContent = `${elapsed}s`;
          }, 100);

          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };

          mediaRecorder.onstop = async () => {
            // Arr√™ter le stream
            stream.getTracks().forEach(track => track.stop());

            // Cr√©er le blob audio
            recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });

            // Afficher l'aper√ßu
            const audioPlayback = document.getElementById('audioPlayback');
            const audioPreview = document.getElementById('audioPreview');

            audioPlayback.src = URL.createObjectURL(recordedAudioBlob);
            audioPreview.style.display = 'block';

            recordingStatus.textContent = 'Enregistrement termin√©';
            recordingTimerEl.textContent = '';

            console.log('Enregistrement termin√©:', recordedAudioBlob.size, 'bytes');
          };

          mediaRecorder.start();
          recordButton.textContent = '‚èπÔ∏è Arr√™ter l\'enregistrement';
          recordButton.className = 'btn-warning';
          recordingStatus.textContent = 'Enregistrement en cours...';
          recordingTimerEl.textContent = '0s';

        } catch (error) {
          console.error('Erreur d\'acc√®s au microphone:', error);
          recordingStatus.textContent = 'Erreur: Microphone non accessible';
          alert('Impossible d\'acc√©der au microphone. V√©rifiez les permissions de votre navigateur.');
        }
      }
    }

    function resetRecording() {
      const audioPreview = document.getElementById('audioPreview');
      const audioPlayback = document.getElementById('audioPlayback');
      const recordingStatus = document.getElementById('recordingStatus');
      const recordingTimerEl = document.getElementById('recordingTimer');

      audioPreview.style.display = 'none';
      audioPlayback.src = '';
      recordedAudioBlob = null;
      recordingStatus.textContent = '';
      recordingTimerEl.textContent = '';
    }

    // Variable pour stocker l'intervalle de polling
    let videoPollingInterval = null;
    let videoPollingAttempts = 0;
    const MAX_POLLING_ATTEMPTS = 30; // 30 tentatives x 3 secondes = 90 secondes max

    // Fonction pour arr√™ter le polling
    function stopVideoPolling() {
      if (videoPollingInterval) {
        clearInterval(videoPollingInterval);
        videoPollingInterval = null;
        videoPollingAttempts = 0;
        console.log('‚èπÔ∏è Polling vid√©o arr√™t√©');
      }
    }

    // Fonction pour r√©cup√©rer l'URL de la vid√©o depuis le webhook
    async function pollVideoStatus(prompt) {
      const webhookUrl = getActiveWebhookUrl();
      videoPollingAttempts++;

      console.log(`üîÑ Tentative de polling ${videoPollingAttempts}/${MAX_POLLING_ATTEMPTS}...`);

      try {
        // Envoyer une requ√™te de v√©rification de statut
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: `\\video ${prompt}`,
            type: 'text',
            checkStatus: true // Indiquer qu'on v√©rifie le statut
          })
        });

        const text = await response.text();
        const parsed = JSON.parse(text);
        const data = Array.isArray(parsed) ? parsed[0] : parsed;

        console.log('üì¶ R√©ponse du polling:', data);

        // Extraire l'URL vid√©o
        let videoUrl = null;
        if (data.content && typeof data.content === 'object') {
          videoUrl = data.content.url || data.content.video_url || data.content.videoUrl;
        }
        videoUrl = videoUrl || data.video_url || data.videoUrl || data.url || (data.metadata?.videoUrl) || (data.metadata?.url);

        const status = (data.content?.status) || data.status || (videoUrl ? 'completed' : 'processing');

        console.log('üé¨ Status:', status, '| URL:', videoUrl);

        // Si la vid√©o est pr√™te
        if (videoUrl && status === 'completed') {
          console.log('‚úÖ Vid√©o trouv√©e!', videoUrl);
          stopVideoPolling();
          loadVideoFromUrl(videoUrl, 'Auto-charg√©e depuis le webhook');
          return true;
        }

        // Si √©chec ou timeout
        if (status === 'failed' || videoPollingAttempts >= MAX_POLLING_ATTEMPTS) {
          stopVideoPolling();
          const manualVideoUrlInput = document.getElementById('manualVideoUrl');
          manualVideoUrlInput.placeholder = 'Le polling a √©chou√©. Collez l\'URL manuellement...';
          console.log('‚ùå Polling termin√© sans succ√®s');
          return false;
        }

        return false;
      } catch (error) {
        console.error('‚ùå Erreur de polling:', error);
        if (videoPollingAttempts >= MAX_POLLING_ATTEMPTS) {
          stopVideoPolling();
        }
        return false;
      }
    }

    // Fonction pour d√©marrer le polling automatique
    function startVideoPolling(prompt) {
      console.log('üöÄ D√©marrage du polling automatique pour la vid√©o...');

      const videoResponseText = document.getElementById('videoResponseText');
      const manualVideoUrlInput = document.getElementById('manualVideoUrl');

      // Arr√™ter tout polling en cours
      stopVideoPolling();

      // Mettre √† jour le placeholder
      manualVideoUrlInput.placeholder = 'üîÑ Recherche automatique de la vid√©o en cours...';

      // D√©marrer le polling toutes les 3 secondes
      videoPollingInterval = setInterval(async () => {
        const found = await pollVideoStatus(prompt);

        // Mettre √† jour le texte avec le nombre de tentatives
        if (!found && videoPollingInterval) {
          videoResponseText.textContent = `‚è≥ G√©n√©ration en cours... (V√©rification ${videoPollingAttempts}/${MAX_POLLING_ATTEMPTS})`;
        }
      }, 3000);

      // Faire une premi√®re v√©rification imm√©diate
      pollVideoStatus(prompt);
    }

    // Fonction pour charger une vid√©o depuis une URL
    function loadVideoFromUrl(videoUrl, source = 'Manuel') {
      console.log('üé¨ Chargement de la vid√©o:', videoUrl, '| Source:', source);

      const videoResponseContent = document.getElementById('videoResponseContent');
      const videoResponseText = document.getElementById('videoResponseText');
      const manualVideoUrlBox = document.getElementById('manualVideoUrlBox');
      const manualVideoUrlInput = document.getElementById('manualVideoUrl');

      // D√©terminer le type de vid√©o par l'extension
      let videoType = 'video/mp4';
      if (videoUrl.includes('.webm')) {
        videoType = 'video/webm';
      } else if (videoUrl.includes('.mov')) {
        videoType = 'video/quicktime';
      }

      // Configurer la vid√©o
      let sourceElement = videoResponseContent.querySelector('source');
      if (!sourceElement) {
        sourceElement = document.createElement('source');
        videoResponseContent.appendChild(sourceElement);
      }
      sourceElement.src = videoUrl;
      sourceElement.type = videoType;
      videoResponseContent.load();
      videoResponseContent.style.display = 'block';

      // Mettre √† jour le texte
      videoResponseText.textContent = `Vid√©o ${source} (Statut: completed)`;

      // Afficher l'URL dans la textbox
      manualVideoUrlInput.value = videoUrl;
      manualVideoUrlInput.placeholder = 'URL de la vid√©o';

      console.log('‚úÖ Vid√©o charg√©e:', videoUrl);
    }

    // Fonction pour charger manuellement l'URL de la vid√©o
    function loadManualVideoUrl() {
      const manualVideoUrl = document.getElementById('manualVideoUrl').value.trim();

      if (!manualVideoUrl) {
        alert('Veuillez entrer une URL de vid√©o!');
        return;
      }

      if (!manualVideoUrl.startsWith('http')) {
        alert('L\'URL doit commencer par http:// ou https://');
        return;
      }

      // Arr√™ter le polling si en cours
      stopVideoPolling();

      loadVideoFromUrl(manualVideoUrl, 'charg√©e manuellement');
    }

    async function testText() {
      const testId = 'test-text';
      const message = document.getElementById('textMessage').value;
      const resultsDiv = document.getElementById('results');
      const webhookUrl = getActiveWebhookUrl();
      resultsDiv.appendChild(createTestContainer(testId, `TEST 1: Texte Simple - "${message}"`));

      const textButton = document.getElementById('textTestButton');

      try {
        // D√©sactiver le bouton pour √©viter les clics multiples
        if (textButton) {
          textButton.disabled = true;
          textButton.textContent = '‚è≥ G√©n√©ration en cours...';
          textButton.style.opacity = '0.6';
          textButton.style.cursor = 'not-allowed';
        }

        // Ajouter le pr√©fixe \text au message
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: `\\text ${message}`,
            type: 'text'
          })
        });

        addAssertion(testId, response.status === 200, 'Status code = 200', '200', response.status);

        const text = await response.text();
        const hasBody = text.length > 0;
        addAssertion(testId, hasBody, 'Response body non vide', '> 0 chars', `${text.length} chars`);

        if (!hasBody) {
          finishTest(testId, false);
          return false;
        }

        let data;
        try {
          const parsed = JSON.parse(text);
          // Le webhook retourne un tableau, prendre le premier √©l√©ment
          data = Array.isArray(parsed) ? parsed[0] : parsed;
          addAssertion(testId, true, 'JSON valide', 'valid JSON', 'valid JSON');

          // Debug: afficher les donn√©es re√ßues
          console.log('üì¶ Donn√©es re√ßues du webhook:', data);
        } catch (e) {
          addAssertion(testId, false, 'JSON valide', 'valid JSON', `Parse error: ${e.message}`);
          finishTest(testId, false);
          return false;
        }

        // Adapter la structure de r√©ponse du webhook
        // Convertir: {type, content, metadata} -> {type, prompt, response}
        const normalizedData = {
          type: data.type || 'text',
          prompt: message,
          response: data.content || data.response || '',
          source: 'text',
          originalMessage: `\\text ${message}`,
          success: data.success,
          metadata: data.metadata
        };

        // Debug: afficher les donn√©es normalis√©es
        console.log('üì¶ Donn√©es normalis√©es:', normalizedData);
        console.log('üìù Type:', normalizedData.type);
        console.log('üìù Response:', normalizedData.response);
        console.log('üìù Longueur response:', normalizedData.response?.length);

        addAssertion(testId, data.hasOwnProperty('type'), 'Champ "type" pr√©sent', 'exists', data.type ? 'exists' : 'missing');
        addAssertion(testId, data.type === 'text', 'Type = "text"', '"text"', `"${data.type}"`);
        addAssertion(testId, data.hasOwnProperty('content') || data.hasOwnProperty('response'), 'Champ "content/response" pr√©sent', 'exists', 'exists');
        const responseText = data.content || data.response || '';
        addAssertion(testId, responseText && responseText.length > 0, 'Response non vide', '> 0 chars', responseText ? `${responseText.length} chars` : 'empty');

        // Afficher la r√©ponse directement sous le textbox
        const textResponseBox = document.getElementById('textResponseBox');
        const textResponseContent = document.getElementById('textResponseContent');
        if (normalizedData.response) {
          textResponseContent.textContent = normalizedData.response;
          textResponseBox.style.display = 'block';
        }

        addJsonOutput(testId, normalizedData);
        finishTest(testId, true);
        return true;
      } catch (error) {
        addAssertion(testId, false, 'Requ√™te r√©ussie', 'no error', error.message);
        finishTest(testId, false);
        return false;
      } finally {
        // R√©activer le bouton apr√®s la g√©n√©ration
        if (textButton) {
          textButton.disabled = false;
          textButton.textContent = '‚ñ∂Ô∏è Tester';
          textButton.style.opacity = '1';
          textButton.style.cursor = 'pointer';
        }
      }
    }

    async function testImage() {
      const testId = 'test-image';
      const prompt = document.getElementById('imagePrompt').value;
      const resultsDiv = document.getElementById('results');
      const webhookUrl = getActiveWebhookUrl();
      const imageButton = document.getElementById('imageTestButton');

      // D√©sactiver le bouton pour √©viter les clics multiples
      if (imageButton) {
        imageButton.disabled = true;
        imageButton.textContent = '‚è≥ G√©n√©ration en cours...';
        imageButton.style.opacity = '0.6';
        imageButton.style.cursor = 'not-allowed';
      }

      resultsDiv.appendChild(createTestContainer(testId, `TEST 2: D√©tection Image - "\\image ${prompt}"`));

      try {
        // Ajouter le pr√©fixe \image au message
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: `\\image ${prompt}`,
            type: 'text'
          })
        });

        addAssertion(testId, response.status === 200, 'Status code = 200', '200', response.status);

        const text = await response.text();
        const hasBody = text.length > 0;
        addAssertion(testId, hasBody, 'Response body non vide', '> 0 chars', `${text.length} chars`);

        if (!hasBody) {
          finishTest(testId, false);
          return false;
        }

        let data;
        try {
          const parsed = JSON.parse(text);
          data = Array.isArray(parsed) ? parsed[0] : parsed;
          addAssertion(testId, true, 'JSON valide', 'valid JSON', 'valid JSON');
        } catch (e) {
          addAssertion(testId, false, 'JSON valide', 'valid JSON', `Parse error: ${e.message}`);
          finishTest(testId, false);
          return false;
        }

        // Normaliser les donn√©es pour l'affichage
        const normalizedData = {
          type: data.type || 'image',
          prompt: prompt,
          image_url: data.image_url || data.imageUrl || (data.metadata?.imageUrl),
          response: data.content || data.response || 'Image g√©n√©r√©e avec succ√®s',
          source: 'text',
          originalMessage: `\\image ${prompt}`,
          success: data.success,
          metadata: data.metadata
        };

        addAssertion(testId, data.type === 'image', 'Type = "image"', '"image"', `"${data.type}"`);

        const hasImageUrl = normalizedData.image_url;
        const hasResponse = normalizedData.response;
        addAssertion(testId, hasImageUrl || hasResponse, 'Champ "image_url" ou "response"', 'exists', hasImageUrl ? 'image_url exists' : (hasResponse ? 'response exists' : 'both missing'));

        // Afficher la r√©ponse directement sous le textbox
        const imageResponseBox = document.getElementById('imageResponseBox');
        const imageResponseContent = document.getElementById('imageResponseContent');
        const imageResponseText = document.getElementById('imageResponseText');
        if (normalizedData.image_url) {
          imageResponseContent.src = normalizedData.image_url;
          imageResponseContent.style.display = 'block';
          imageResponseBox.style.display = 'block';
        }
        if (normalizedData.response) {
          imageResponseText.textContent = normalizedData.response;
        }

        addJsonOutput(testId, normalizedData);
        finishTest(testId, true);
        return true;
      } catch (error) {
        addAssertion(testId, false, 'Requ√™te r√©ussie', 'no error', error.message);
        finishTest(testId, false);
        return false;
      } finally {
        // R√©activer le bouton dans tous les cas (succ√®s ou erreur)
        if (imageButton) {
          imageButton.disabled = false;
          imageButton.textContent = '‚ñ∂Ô∏è Tester';
          imageButton.style.opacity = '1';
          imageButton.style.cursor = 'pointer';
        }
      }
    }

    async function testVideo() {
      const testId = 'test-video';
      const prompt = document.getElementById('videoPrompt').value;
      const duration = document.getElementById('videoDuration').value;
      const aspectRatio = document.getElementById('videoAspectRatio').value;
      const fps = document.getElementById('videoFps').value;
      const resultsDiv = document.getElementById('results');
      const webhookUrl = getActiveWebhookUrl();
      resultsDiv.appendChild(createTestContainer(testId, `TEST 3: D√©tection Video - "\\video ${prompt}" (${duration}s, ${aspectRatio}, ${fps}fps)`));

      const videoButton = document.getElementById('videoTestButton');

      try {
        // D√©sactiver le bouton pour √©viter les clics multiples
        if (videoButton) {
          videoButton.disabled = true;
          videoButton.textContent = '‚è≥ G√©n√©ration en cours...';
          videoButton.style.opacity = '0.6';
          videoButton.style.cursor = 'not-allowed';
        }

        // Ajouter le pr√©fixe \video au message avec les param√®tres
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: `\\video ${prompt}`,
            type: 'text',
            videoParams: {
              duration: parseInt(duration),
              aspectRatio: aspectRatio,
              fps: parseInt(fps)
            }
          })
        });

        addAssertion(testId, response.status === 200, 'Status code = 200', '200', response.status);

        const text = await response.text();
        const hasBody = text.length > 0;
        addAssertion(testId, hasBody, 'Response body non vide', '> 0 chars', `${text.length} chars`);

        if (!hasBody) {
          finishTest(testId, false);
          return false;
        }

        let data;
        try {
          const parsed = JSON.parse(text);
          data = Array.isArray(parsed) ? parsed[0] : parsed;
          addAssertion(testId, true, 'JSON valide', 'valid JSON', 'valid JSON');

          console.log('üì¶ Donn√©es brutes du webhook (video):', parsed);
          console.log('üì¶ Donn√©es extraites:', data);
        } catch (e) {
          addAssertion(testId, false, 'JSON valide', 'valid JSON', `Parse error: ${e.message}`);
          finishTest(testId, false);
          return false;
        }

        // Extraire la r√©ponse en g√©rant les diff√©rents formats possibles
        let responseText = '';
        let extractedStatus = '';
        let extractedVideoUrl = null;

        if (typeof data.content === 'string') {
          responseText = data.content;
        } else if (typeof data.response === 'string') {
          responseText = data.response;
        } else if (typeof data.message === 'string') {
          responseText = data.message;
        } else if (data.content && typeof data.content === 'object') {
          // Si content est un objet, extraire les informations structur√©es
          const message = data.content.message || '';
          const instructions = data.content.instructions || '';
          const contentStatus = data.content.status || '';

          // Combiner le message et les instructions
          responseText = message;
          if (instructions && instructions !== message) {
            responseText += '\n\nüí° ' + instructions;
          }

          extractedStatus = contentStatus;
          extractedVideoUrl = data.content.url || data.content.video_url || data.content.videoUrl;
        } else if (data.response && typeof data.response === 'object') {
          // Si response est un objet, essayer d'extraire le texte
          responseText = data.response.text || data.response.message || JSON.stringify(data.response);
        } else {
          responseText = data.video_url || data.videoUrl || data.url ? 'Vid√©o g√©n√©r√©e avec succ√®s' : 'G√©n√©ration vid√©o en cours...';
        }

        console.log('üìù Type de data.content:', typeof data.content, data.content);
        console.log('üìù Type de data.response:', typeof data.response, data.response);
        console.log('üìù responseText extrait:', responseText);
        console.log('üìù extractedStatus:', extractedStatus);
        console.log('üìù extractedVideoUrl:', extractedVideoUrl);

        // Normaliser les donn√©es pour l'affichage
        // Si le type est "info" mais qu'on a des donn√©es vid√©o dans metadata, c'est une r√©ponse vid√©o
        const isVideoResponse = data.type === 'video' || (data.type === 'info' && data.metadata?.inputType === 'video-generation');

        const normalizedData = {
          type: isVideoResponse ? 'video' : (data.type || 'video'),
          prompt: prompt,
          video_url: extractedVideoUrl || data.video_url || data.videoUrl || data.url || (data.metadata?.videoUrl) || (data.metadata?.url),
          task_id: data.task_id || data.taskId || (data.metadata?.taskId) || (data.content?.task_id),
          status: extractedStatus || data.status || (extractedVideoUrl || data.video_url || data.videoUrl || data.url ? 'completed' : 'processing'),
          response: responseText,
          source: 'text',
          originalMessage: `\\video ${prompt}`,
          success: data.success,
          metadata: data.metadata
        };

        console.log('üì¶ Donn√©es normalis√©es (video):', normalizedData);
        console.log('üé¨ URL vid√©o extraite:', normalizedData.video_url);
        console.log('üéØ isVideoResponse:', isVideoResponse);

        addAssertion(testId, isVideoResponse, 'Type = "video" ou info video', '"video"', `"${data.type}"`);

        const hasTaskId = normalizedData.task_id;
        const hasVideoUrl = normalizedData.video_url;
        const hasResponse = normalizedData.response;
        addAssertion(testId, hasTaskId || hasVideoUrl || hasResponse, 'Champ video pr√©sent', 'exists', hasTaskId ? 'task_id exists' : (hasVideoUrl ? 'video_url exists' : (hasResponse ? 'response exists' : 'all missing')));

        // Afficher la r√©ponse directement sous le textbox
        const videoResponseBox = document.getElementById('videoResponseBox');
        const videoResponseContent = document.getElementById('videoResponseContent');
        const videoResponseText = document.getElementById('videoResponseText');

        // R√©initialiser l'affichage
        videoResponseContent.style.display = 'none';
        videoResponseText.textContent = '';
        videoResponseBox.style.display = 'none';

        console.log('üì¶ normalizedData pour vid√©o:', normalizedData);
        console.log('üé¨ video_url:', normalizedData.video_url);
        console.log('üìù response:', normalizedData.response);
        console.log('üî¢ response type:', typeof normalizedData.response);

        const manualVideoUrlBox = document.getElementById('manualVideoUrlBox');
        const manualVideoUrlInput = document.getElementById('manualVideoUrl');

        if (normalizedData.video_url) {
          // D√©terminer le type de vid√©o par l'extension
          const videoUrl = normalizedData.video_url;
          let videoType = 'video/mp4';
          if (videoUrl.includes('.webm')) {
            videoType = 'video/webm';
          } else if (videoUrl.includes('.mov')) {
            videoType = 'video/quicktime';
          }

          // Trouver l'√©l√©ment source ou le cr√©er s'il n'existe pas
          let sourceElement = videoResponseContent.querySelector('source');
          if (!sourceElement) {
            sourceElement = document.createElement('source');
            videoResponseContent.appendChild(sourceElement);
          }
          sourceElement.src = videoUrl;
          sourceElement.type = videoType;
          videoResponseContent.load();
          videoResponseContent.style.display = 'block';
          videoResponseBox.style.display = 'block';

          console.log('üé¨ Vid√©o configur√©e:', videoUrl, 'Type:', videoType);

          if (normalizedData.response) {
            const responseText = String(normalizedData.response);
            const statusText = normalizedData.status ? ` (Statut: ${normalizedData.status})` : '';
            videoResponseText.textContent = responseText + statusText;
            console.log('‚úÖ Texte de r√©ponse d√©fini:', responseText + statusText);
          }

          // Afficher l'URL dans la textbox
          manualVideoUrlInput.value = videoUrl;
          manualVideoUrlBox.style.display = 'block';
        } else if (normalizedData.task_id || normalizedData.status === 'processing') {
          // Vid√©o en cours de g√©n√©ration
          const responseMsg = String(normalizedData.response || 'G√©n√©ration en cours...');
          videoResponseText.textContent = `‚è≥ ${responseMsg}`;
          videoResponseBox.style.display = 'block';

          // Afficher la zone de saisie manuelle pour coller l'URL une fois pr√™te
          manualVideoUrlInput.value = '';
          manualVideoUrlInput.placeholder = 'üîÑ Recherche automatique en cours...';
          manualVideoUrlBox.style.display = 'block';

          // D√©marrer le polling automatique pour r√©cup√©rer l'URL de la vid√©o
          console.log('üöÄ Lancement du polling automatique...');
          startVideoPolling(prompt);
        } else if (normalizedData.response) {
          // Message uniquement
          videoResponseText.textContent = String(normalizedData.response);
          videoResponseBox.style.display = 'block';
        }

        addJsonOutput(testId, normalizedData);
        finishTest(testId, true);
        return true;
      } catch (error) {
        addAssertion(testId, false, 'Requ√™te r√©ussie', 'no error', error.message);
        finishTest(testId, false);
        return false;
      } finally {
        // R√©activer le bouton apr√®s la g√©n√©ration
        if (videoButton) {
          videoButton.disabled = false;
          videoButton.textContent = '‚ñ∂Ô∏è Tester';
          videoButton.style.opacity = '1';
          videoButton.style.cursor = 'pointer';
        }
      }
    }

    async function testVoice() {
      const testId = 'test-voice';
      const resultsDiv = document.getElementById('results');
      const webhookUrl = getActiveWebhookUrl();

      const voiceButton = document.getElementById('voiceTestButton');

      // V√©rifier qu'un enregistrement existe
      if (!recordedAudioBlob) {
        alert('Veuillez d\'abord enregistrer un message vocal!');
        return false;
      }

      resultsDiv.appendChild(createTestContainer(testId, `TEST 4: Input Voix - Audio enregistr√© (${Math.round(recordedAudioBlob.size / 1024)}KB)`));

      try {
        // D√©sactiver le bouton pour √©viter les clics multiples
        if (voiceButton) {
          voiceButton.disabled = true;
          voiceButton.textContent = '‚è≥ Traitement en cours...';
          voiceButton.style.opacity = '0.6';
          voiceButton.style.cursor = 'not-allowed';
        }

        // Convertir le blob audio en base64
        const reader = new FileReader();
        const audioBase64 = await new Promise((resolve, reject) => {
          reader.onloadend = () => {
            const base64 = reader.result.split(',')[1];
            resolve(base64);
          };
          reader.onerror = reject;
          reader.readAsDataURL(recordedAudioBlob);
        });

        console.log('Audio base64 length:', audioBase64.length);

        // Ajouter le pr√©fixe \audio
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: `\\audio`,
            audio_data: audioBase64,
            type: 'voice',
            format: 'webm',
            size: recordedAudioBlob.size
          })
        });

        addAssertion(testId, response.status === 200, 'Status code = 200', '200', response.status);

        const text = await response.text();
        const hasBody = text.length > 0;
        addAssertion(testId, hasBody, 'Response body non vide', '> 0 chars', `${text.length} chars`);

        if (!hasBody) {
          finishTest(testId, false);
          return false;
        }

        let data;
        try {
          const parsed = JSON.parse(text);
          data = Array.isArray(parsed) ? parsed[0] : parsed;
          addAssertion(testId, true, 'JSON valide', 'valid JSON', 'valid JSON');
        } catch (e) {
          addAssertion(testId, false, 'JSON valide', 'valid JSON', `Parse error: ${e.message}`);
          finishTest(testId, false);
          return false;
        }

        // Extraire la transcription ou la r√©ponse
        const transcription = data.transcription || data.content || data.response || '';

        addAssertion(testId, data.type === 'text' || data.type === 'audio', 'Type valide', '"text" ou "audio"', `"${data.type}"`);
        addAssertion(testId, transcription.length > 0, 'Transcription pr√©sente', '> 0 chars', `${transcription.length} chars`);

        // Afficher la transcription
        const voiceResponseBox = document.getElementById('voiceResponseBox');
        const voiceResponseText = document.getElementById('voiceResponseText');

        if (transcription) {
          voiceResponseText.textContent = transcription;
          voiceResponseBox.style.display = 'block';
        }

        addJsonOutput(testId, data);
        finishTest(testId, true);
        return true;
      } catch (error) {
        addAssertion(testId, false, 'Requ√™te r√©ussie', 'no error', error.message);
        finishTest(testId, false);
        return false;
      } finally {
        // R√©activer le bouton apr√®s le traitement
        if (voiceButton) {
          voiceButton.disabled = false;
          voiceButton.textContent = '‚ñ∂Ô∏è Tester';
          voiceButton.style.opacity = '1';
          voiceButton.style.cursor = 'pointer';
        }
      }
    }

    async function runTest(testType) {
      clearResults();

      switch(testType) {
        case 'text':
          await testText();
          break;
        case 'image':
          await testImage();
          break;
        case 'video':
          await testVideo();
          break;
        case 'voice':
          await testVoice();
          break;
      }

      showSummary();
    }

    async function runAllTests() {
      clearResults();

      await testText();
      await new Promise(r => setTimeout(r, 1000));

      await testImage();
      await new Promise(r => setTimeout(r, 1000));

      await testVideo();
      await new Promise(r => setTimeout(r, 1000));

      await testVoice();

      showSummary();
    }
  </script>
</body>
</html>








